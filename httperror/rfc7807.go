package httperror

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// RFC7807Error represents a Problem Details for HTTP APIs as defined in RFC7807.
// It provides a standardized way to describe the details of a problem that
// occurred during an HTTP request.
//
// The RFC7807 standard defines a problem details object with the following fields:
// - Type: A URI reference that identifies the problem type
// - Title: A short, human-readable summary of the problem type
// - Status: The HTTP status code generated by the origin server
// - Detail: A human-readable explanation specific to this occurrence of the problem
// - Instance: A URI reference that identifies the specific occurrence of the problem
//
// See: https://tools.ietf.org/html/rfc7807
type RFC7807Error struct {
	// Type is a URI reference that identifies the problem type.
	// When dereferenced, it SHOULD provide human-readable documentation for the problem type.
	// When this member is not present, its value is assumed to be "about:blank".
	Type string `json:"type,omitempty"`

	// Title is a short, human-readable summary of the problem type.
	// It SHOULD NOT change from occurrence to occurrence of the problem,
	// except for purposes of localization.
	Title string `json:"title,omitempty"`

	// Status is the HTTP status code generated by the origin server for this occurrence of the problem.
	Status int `json:"status,omitempty"`

	// Detail is a human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail,omitempty"`

	// Instance is a URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance,omitempty"`

	// Extensions is a map of additional members that provide information about the problem.
	// These can be application-specific or extended members from other specifications.
	Extensions map[string]interface{} `json:"-"`
}

// NewRFC7807Error creates a new RFC7807Error with the specified status, title, and detail.
// The Type field is set to "about:blank" by default as per RFC7807 specification.
func NewRFC7807Error(status int, title, detail string) *RFC7807Error {
	return &RFC7807Error{
		Type:   "about:blank", // Default type as per RFC7807
		Title:  title,
		Status: status,
		Detail: detail,
	}
}

// WithType sets the Type field of the RFC7807Error and returns the error for method chaining.
// The Type field is a URI reference that identifies the problem type.
// When dereferenced, it SHOULD provide human-readable documentation for the problem type.
func (p *RFC7807Error) WithType(typeURI string) *RFC7807Error {
	p.Type = typeURI
	return p
}

// WithInstance sets the Instance field of the RFC7807Error and returns the error for method chaining.
// The Instance field is a URI reference that identifies the specific occurrence of the problem.
// It may or may not yield further information if dereferenced.
func (p *RFC7807Error) WithInstance(instance string) *RFC7807Error {
	p.Instance = instance
	p.Instance = instance
	return p
}

// WithExtension adds an extension property to the RFC7807Error and returns the error for method chaining.
// Extensions are additional members that provide information about the problem.
// They will be serialized in the JSON output alongside the standard fields.
func (p *RFC7807Error) WithExtension(key string, value interface{}) *RFC7807Error {
	if p.Extensions == nil {
		p.Extensions = make(map[string]interface{})
	}
	p.Extensions[key] = value
	return p
}

// Error returns a string representation of the problem detail, implementing the error interface.
func (p *RFC7807Error) Error() string {
	return fmt.Sprintf("%d: %s - %s", p.Status, p.Title, p.Detail)
}

// StatusCode returns the HTTP status code of the problem detail.
func (p *RFC7807Error) StatusCode() int {
	return p.Status
}

// ErrorMessage returns the detail message of the problem detail.
func (p *RFC7807Error) ErrorMessage() string {
	return p.Detail
}

// MarshalJSON implements the json.Marshaler interface to include extensions in the JSON output.
func (p *RFC7807Error) MarshalJSON() ([]byte, error) {
	type Alias RFC7807Error
	data, err := json.Marshal(&struct {
		*Alias
	}{
		Alias: (*Alias)(p),
	})
	if err != nil {
		return nil, err
	}

	if len(p.Extensions) == 0 {
		return data, nil
	}

	// Unmarshal the marshaled data into a map
	var result map[string]interface{}
	if err := json.Unmarshal(data, &result); err != nil {
		return nil, err
	}

	// Add extensions to the map
	for k, v := range p.Extensions {
		result[k] = v
	}

	// Marshal the map back to JSON
	return json.Marshal(result)
}

// BadRequestProblem7807 creates a new RFC7807Error with status 400 (Bad Request).
// If title is empty, it defaults to "Bad Request".
func BadRequestProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Bad Request"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusBadRequest, t, detail)
}

// UnauthorizedProblem7807 creates a new RFC7807Error with status 401 (Unauthorized).
// If title is empty, it defaults to "Unauthorized".
func UnauthorizedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Unauthorized"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusUnauthorized, t, detail)
}

// PaymentRequiredProblem7807 creates a new RFC7807Error with status 402 (Payment Required).
// If title is empty, it defaults to the standard HTTP status text.
func PaymentRequiredProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Payment Required"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusPaymentRequired, t, detail)
}

// ForbiddenProblem7807 creates a new RFC7807Error with status 403 (Forbidden).
// If title is empty, it defaults to the standard HTTP status text.
func ForbiddenProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Forbidden"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusForbidden, t, detail)
}

// NotFoundProblem7807 creates a new RFC7807Error with status 404 (Not Found).
// If title is empty, it defaults to the standard HTTP status text.
func NotFoundProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Not Found"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusNotFound, t, detail)
}

// MethodNotAllowedProblem7807 creates a new RFC7807Error with status 405 (Method Not Allowed).
// If title is empty, it defaults to the standard HTTP status text.
func MethodNotAllowedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Method Not Allowed"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusMethodNotAllowed, t, detail)
}

// NotAcceptableProblem7807 creates a new RFC7807Error with status 406 (Not Acceptable).
// If title is empty, it defaults to the standard HTTP status text.
func NotAcceptableProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Not Acceptable"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusNotAcceptable, t, detail)
}

// ProxyAuthRequiredProblem7807 creates a new RFC7807Error with status 407 (Proxy Authentication Required).
// If title is empty, it defaults to the standard HTTP status text.
func ProxyAuthRequiredProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Proxy Authentication Required"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusProxyAuthRequired, t, detail)
}

// RequestTimeoutProblem7807 creates a new RFC7807Error with status 408 (Request Timeout).
// If title is empty, it defaults to the standard HTTP status text.
func RequestTimeoutProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Request Timeout"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusRequestTimeout, t, detail)
}

// ConflictProblem7807 creates a new RFC7807Error with status 409 (Conflict).
// If title is empty, it defaults to the standard HTTP status text.
func ConflictProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Conflict"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusConflict, t, detail)
}

// GoneProblem7807 creates a new RFC7807Error with status 410 (Gone).
// If title is empty, it defaults to the standard HTTP status text.
func GoneProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Gone"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusGone, t, detail)
}

// LengthRequiredProblem7807 creates a new RFC7807Error with status 411 (Length Required).
// If title is empty, it defaults to the standard HTTP status text.
func LengthRequiredProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Length Required"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusLengthRequired, t, detail)
}

// PreconditionFailedProblem7807 creates a new RFC7807Error with status 412 (Precondition Failed).
// If title is empty, it defaults to the standard HTTP status text.
func PreconditionFailedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Precondition Failed"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusPreconditionFailed, t, detail)
}

// PayloadTooLargeProblem7807 creates a new RFC7807Error with status 413 (Payload Too Large).
// If title is empty, it defaults to the standard HTTP status text.
func PayloadTooLargeProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Payload Too Large"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusRequestEntityTooLarge, t, detail)
}

// URITooLongProblem7807 creates a new RFC7807Error with status 414 (URI Too Long).
// If title is empty, it defaults to the standard HTTP status text.
func URITooLongProblem7807(detail string, title ...string) *RFC7807Error {
	t := "URI Too Long"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusRequestURITooLong, t, detail)
}

// UnsupportedMediaTypeProblem7807 creates a new RFC7807Error with status 415 (Unsupported Media Type).
// If title is empty, it defaults to the standard HTTP status text.
func UnsupportedMediaTypeProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Unsupported Media Type"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusUnsupportedMediaType, t, detail)
}

// RangeNotSatisfiableProblem7807 creates a new RFC7807Error with status 416 (Range Not Satisfiable).
// If title is empty, it defaults to the standard HTTP status text.
func RangeNotSatisfiableProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Range Not Satisfiable"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusRequestedRangeNotSatisfiable, t, detail)
}

// ExpectationFailedProblem7807 creates a new RFC7807Error with status 417 (Expectation Failed).
// If title is empty, it defaults to the standard HTTP status text.
func ExpectationFailedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Expectation Failed"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusExpectationFailed, t, detail)
}

// MisdirectedRequestProblem7807 creates a new RFC7807Error with status 421 (Misdirected Request).
// If title is empty, it defaults to the standard HTTP status text.
func MisdirectedRequestProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Misdirected Request"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusMisdirectedRequest, t, detail)
}

// LockedProblem7807 creates a new RFC7807Error with status 423 (Locked).
// If title is empty, it defaults to the standard HTTP status text.
func LockedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Locked"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusLocked, t, detail)
}

// FailedDependencyProblem7807 creates a new RFC7807Error with status 424 (Failed Dependency).
// If title is empty, it defaults to the standard HTTP status text.
func FailedDependencyProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Failed Dependency"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusFailedDependency, t, detail)
}

// UpgradeRequiredProblem7807 creates a new RFC7807Error with status 426 (Upgrade Required).
// If title is empty, it defaults to the standard HTTP status text.
func UpgradeRequiredProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Upgrade Required"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusUpgradeRequired, t, detail)
}

// PreconditionRequiredProblem7807 creates a new RFC7807Error with status 428 (Precondition Required).
// If title is empty, it defaults to the standard HTTP status text.
func PreconditionRequiredProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Precondition Required"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusPreconditionRequired, t, detail)
}

// TooManyRequestsProblem7807 creates a new RFC7807Error with status 429 (Too Many Requests).
// If title is empty, it defaults to the standard HTTP status text.
func TooManyRequestsProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Too Many Requests"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusTooManyRequests, t, detail)
}

// RequestHeaderFieldsTooLargeProblem7807 creates a new RFC7807Error with status 431 (Request Header Fields Too Large).
// If title is empty, it defaults to the standard HTTP status text.
func RequestHeaderFieldsTooLargeProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Request Header Fields Too Large"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusRequestHeaderFieldsTooLarge, t, detail)
}

// UnavailableForLegalReasonsProblem7807 creates a new RFC7807Error with status 451 (Unavailable For Legal Reasons).
// If title is empty, it defaults to the standard HTTP status text.
func UnavailableForLegalReasonsProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Unavailable For Legal Reasons"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusUnavailableForLegalReasons, t, detail)
}

// NotImplementedProblem7807 creates a new RFC7807Error with status 501 (Not Implemented).
// If title is empty, it defaults to the standard HTTP status text.
func NotImplementedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Not Implemented"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusNotImplemented, t, detail)
}

// BadGatewayProblem7807 creates a new RFC7807Error with status 502 (Bad Gateway).
// If title is empty, it defaults to the standard HTTP status text.
func BadGatewayProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Bad Gateway"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusBadGateway, t, detail)
}

// GatewayTimeoutProblem7807 creates a new RFC7807Error with status 504 (Gateway Timeout).
// If title is empty, it defaults to the standard HTTP status text.
func GatewayTimeoutProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Gateway Timeout"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusGatewayTimeout, t, detail)
}

// HTTPVersionNotSupportedProblem7807 creates a new RFC7807Error with status 505 (HTTP Version Not Supported).
// If title is empty, it defaults to the standard HTTP status text.
func HTTPVersionNotSupportedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "HTTP Version Not Supported"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusHTTPVersionNotSupported, t, detail)
}

// VariantAlsoNegotiatesProblem7807 creates a new RFC7807Error with status 506 (Variant Also Negotiates).
// If title is empty, it defaults to the standard HTTP status text.
func VariantAlsoNegotiatesProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Variant Also Negotiates"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusVariantAlsoNegotiates, t, detail)
}

// InsufficientStorageProblem7807 creates a new RFC7807Error with status 507 (Insufficient Storage).
// If title is empty, it defaults to the standard HTTP status text.
func InsufficientStorageProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Insufficient Storage"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusInsufficientStorage, t, detail)
}

// LoopDetectedProblem7807 creates a new RFC7807Error with status 508 (Loop Detected).
// If title is empty, it defaults to the standard HTTP status text.
func LoopDetectedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Loop Detected"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusLoopDetected, t, detail)
}

// NotExtendedProblem7807 creates a new RFC7807Error with status 510 (Not Extended).
// If title is empty, it defaults to the standard HTTP status text.
func NotExtendedProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Not Extended"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusNotExtended, t, detail)
}

// NetworkAuthenticationRequiredProblem7807 creates a new RFC7807Error with status 511 (Network Authentication Required).
// If title is empty, it defaults to the standard HTTP status text.
func NetworkAuthenticationRequiredProblem7807(detail string, title ...string) *RFC7807Error {
	t := "Network Authentication Required"
	if len(title) > 0 && title[0] != "" {
		t = title[0]
	}
	return NewRFC7807Error(http.StatusNetworkAuthenticationRequired, t, detail)
}

// ToHttpError converts the RFC7807Error to an HttpError with JSON representation of the problem.
// The resulting HttpError will have the content type set to "application/problem+json".
func (p *RFC7807Error) ToHttpError() *HttpError {
	const ContentType = "application/problem+json"
	jsonBytes, err := json.Marshal(p)
	if err != nil {
		// If marshaling fails, fall back to just using the detail
		return New(p.Status, p.Detail, "text/plain")
	}
	return New(p.Status, string(jsonBytes), ContentType)
}
